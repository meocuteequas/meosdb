create type "public"."user_permission" as enum ('USER', 'ADMIN', 'MANAGER');

create table "public"."Cats" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" character varying not null
);


alter table "public"."Cats" enable row level security;

create table "public"."Recipes" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "name" character varying not null,
    "description" character varying not null,
    "src" character varying not null,
    "user_id" uuid not null default auth.uid()
);


alter table "public"."Recipes" enable row level security;

create table "public"."grades" (
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null default auth.uid(),
    "grade" smallint not null,
    "id" uuid not null default gen_random_uuid()
);


alter table "public"."grades" enable row level security;

CREATE UNIQUE INDEX "Cats_pkey" ON public."Cats" USING btree (id);

CREATE UNIQUE INDEX "Grades_pkey" ON public.grades USING btree (id);

CREATE UNIQUE INDEX "Recipes_pkey" ON public."Recipes" USING btree (id);

alter table "public"."Cats" add constraint "Cats_pkey" PRIMARY KEY using index "Cats_pkey";

alter table "public"."Recipes" add constraint "Recipes_pkey" PRIMARY KEY using index "Recipes_pkey";

alter table "public"."grades" add constraint "Grades_pkey" PRIMARY KEY using index "Grades_pkey";

alter table "public"."Recipes" add constraint "Recipes_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE RESTRICT ON DELETE RESTRICT not valid;

alter table "public"."Recipes" validate constraint "Recipes_user_id_fkey";

alter table "public"."grades" add constraint "grades_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."grades" validate constraint "grades_user_id_fkey";

create policy "Enable read access to employee only"
on "public"."Cats"
as permissive
for select
to authenticated
using ((((auth.jwt() -> 'user_metadata'::text) ->> 'role'::text) = 'employee'::text));


create policy "Enable select for users based on role"
on "public"."Recipes"
as permissive
for select
to authenticated
using ((((auth.jwt() -> 'user_metadata'::text) ->> 'role'::text) = 'employee'::text));


create policy "Only allow employee to insert"
on "public"."Recipes"
as permissive
for insert
to authenticated
with check ((((auth.jwt() -> 'user_metadata'::text) ->> 'role'::text) = 'employee'::text));


create schema if not exists "rbac";

create table "rbac"."permission" (
    "id" uuid not null default gen_random_uuid(),
    "type" text not null,
    "object" text not null,
    "action" text generated always as (((type || ' on '::text) || object)) stored,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "deleted_at" timestamp with time zone
);


create table "rbac"."role" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null,
    "description" text,
    "active" boolean default false,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "deleted_at" timestamp with time zone
);


create table "rbac"."role_permission" (
    "role_id" uuid not null,
    "permission_id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "deleted_at" timestamp with time zone
);


create table "rbac"."user_role" (
    "user_id" uuid not null,
    "role_id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "deleted_at" timestamp with time zone
);


CREATE UNIQUE INDEX permission_pkey ON rbac.permission USING btree (id);

CREATE UNIQUE INDEX role_permission_pkey ON rbac.role_permission USING btree (role_id, permission_id);

CREATE UNIQUE INDEX role_pkey ON rbac.role USING btree (id);

CREATE UNIQUE INDEX user_role_pkey ON rbac.user_role USING btree (user_id, role_id);

alter table "rbac"."permission" add constraint "permission_pkey" PRIMARY KEY using index "permission_pkey";

alter table "rbac"."role" add constraint "role_pkey" PRIMARY KEY using index "role_pkey";

alter table "rbac"."role_permission" add constraint "role_permission_pkey" PRIMARY KEY using index "role_permission_pkey";

alter table "rbac"."user_role" add constraint "user_role_pkey" PRIMARY KEY using index "user_role_pkey";

alter table "rbac"."role_permission" add constraint "role_permission_permission_id_fkey" FOREIGN KEY (permission_id) REFERENCES rbac.permission(id) not valid;

alter table "rbac"."role_permission" validate constraint "role_permission_permission_id_fkey";

alter table "rbac"."role_permission" add constraint "role_permission_role_id_fkey" FOREIGN KEY (role_id) REFERENCES rbac.role(id) not valid;

alter table "rbac"."role_permission" validate constraint "role_permission_role_id_fkey";

alter table "rbac"."user_role" add constraint "user_role_role_id_fkey" FOREIGN KEY (role_id) REFERENCES rbac.role(id) not valid;

alter table "rbac"."user_role" validate constraint "user_role_role_id_fkey";

alter table "rbac"."user_role" add constraint "user_role_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "rbac"."user_role" validate constraint "user_role_user_id_fkey";

create or replace view "rbac"."granular_permissions" as  SELECT ur.user_id,
    r.name AS role,
    p.action AS permission
   FROM (((rbac.permission p
     LEFT JOIN rbac.role_permission rp ON ((rp.permission_id = p.id)))
     LEFT JOIN rbac.role r ON ((r.id = rp.role_id)))
     LEFT JOIN rbac.user_role ur ON ((ur.role_id = r.id)))
  WHERE ((r.active = true) AND (r.deleted_at IS NULL) AND (ur.deleted_at IS NULL) AND (rp.deleted_at IS NULL) AND (p.deleted_at IS NULL));

create policy "Enable insert for authenticated users"
on "public"."grades"
as permissive
for insert
to authenticated
with check ((EXISTS ( SELECT 1
   FROM rbac.granular_permissions gp
  WHERE ((gp.user_id = auth.uid()) AND (gp.permission = 'INSERT on GRADES'::text)))));


create policy "Enable read for authenticated users"
on "public"."grades"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM rbac.granular_permissions gp
  WHERE ((gp.user_id = auth.uid()) AND (gp.permission = 'SELECT on GRADES'::text)))));


